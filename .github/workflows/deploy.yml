name: Deploy App Provedor to Production

on:
  push:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: juniorssilvaa/app_provedor

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: app_provedor_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install dj-database-url psycopg2-binary

      - name: Run tests
        env:
          SECRET_KEY: test-secret-key
          DEBUG: True
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/app_provedor_test
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          cd backend
          python manage.py migrate
          python manage.py test

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build & push BACKEND
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}

      - name: Build & push WEBHOOK
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-webhook:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-webhook:${{ github.sha }}

      - name: Build & push FRONTEND
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code (to get docker-compose.yml)
        uses: actions/checkout@v4

      - name: Deploy to Portainer
        env:
          PORTAINER_URL: https://app-provedor.niochat.com.br
          PORTAINER_API_KEY: ${{ secrets.PORTAINER_API_KEY }}
          IMAGE_TAG: ${{ github.sha }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          echo "üîç Verificando conex√£o com Portainer..."
          echo "Fetching stacks from $PORTAINER_URL/api/stacks..."
          STACKS=$(curl -s -H "X-API-Key: $PORTAINER_API_KEY" "$PORTAINER_URL/api/stacks")
          
          # Debug: Mostrar a resposta crua para entender o erro
          echo "DEBUG: Portainer Response Body:"
          echo "$STACKS"
          
          # Verifica se a resposta √© um array JSON (come√ßa com [)
          if [[ ! "$STACKS" =~ ^\[ ]]; then
             echo "‚ùå Erro: A resposta do Portainer n√£o √© uma lista de stacks v√°lida."
             echo "Verifique se a PORTAINER_API_KEY est√° correta e tem permiss√µes."
             exit 1
          fi

          STACK_ID=$(echo "$STACKS" | jq -r '.[] | select(.Name=="app_provedor") | .Id')
          
          # Se a stack n√£o existir, voc√™ pode precisar criar ou apenas logar o erro
          if [ "$STACK_ID" == "null" ] || [ -z "$STACK_ID" ]; then
            echo "‚ùå Stack 'app_provedor' n√£o encontrada no Portainer!"
            exit 1
          fi
          
          echo "‚úÖ Stack encontrada: ID=$STACK_ID"
          
          # Verificar se a rede appNet existe, se n√£o, criar
          echo "üîç Verificando se a rede 'appNet' existe..."
          NETWORKS=$(curl -s -H "X-API-Key: $PORTAINER_API_KEY" "$PORTAINER_URL/api/endpoints/1/docker/networks")
          NETWORK_EXISTS=$(echo "$NETWORKS" | jq -r '.[] | select(.Name=="appNet") | .Id')
          
          if [ -z "$NETWORK_EXISTS" ] || [ "$NETWORK_EXISTS" == "null" ]; then
            echo "üì° Rede 'appNet' n√£o encontrada. Criando rede..."
            CREATE_NETWORK_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "X-API-Key: $PORTAINER_API_KEY" \
              -H "Content-Type: application/json" \
              --data '{"Name":"appNet","Driver":"overlay","Attachable":true,"Scope":"swarm"}' \
              "$PORTAINER_URL/api/endpoints/1/docker/networks/create")
            
            CREATE_NETWORK_CODE=$(echo "$CREATE_NETWORK_RESPONSE" | tail -n1)
            if [ "$CREATE_NETWORK_CODE" -eq 201 ] || [ "$CREATE_NETWORK_CODE" -eq 200 ]; then
              echo "‚úÖ Rede 'appNet' criada com sucesso!"
            else
              echo "‚ö†Ô∏è  Aviso: N√£o foi poss√≠vel criar a rede 'appNet'. HTTP Code: $CREATE_NETWORK_CODE"
              echo "   A rede pode j√° existir ou voc√™ precisa cri√°-la manualmente no Portainer."
            fi
          else
            echo "‚úÖ Rede 'appNet' j√° existe (ID: $NETWORK_EXISTS)"
          fi

          # L√™ o arquivo original que j√° usa ${IMAGE_TAG:-latest}
          COMPOSE=$(cat docker-compose.yml)
          
          # Escapa o conte√∫do do docker-compose para JSON
          ESCAPED=$(echo "$COMPOSE" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          
          echo "üîÑ Atualizando stack no Portainer..."
          echo "üì¶ IMAGE_TAG: $IMAGE_TAG"
          
          # Faz a atualiza√ß√£o da stack no Portainer
          # Enviamos o IMAGE_TAG via vari√°vel de ambiente da stack para o Portainer usar no pull
          echo "üîÑ Atualizando stack no Portainer (Stack ID: $STACK_ID, Endpoint ID: 1)..."
          RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "X-API-Key: $PORTAINER_API_KEY" \
            -H "Content-Type: application/json" \
            --data "{\"StackFileContent\":\"$ESCAPED\",\"Env\":[{\"name\":\"IMAGE_TAG\",\"value\":\"$IMAGE_TAG\"}],\"PullImage\":true,\"ForceRecreate\":true}" \
            "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=1")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 204 ]; then
            echo "‚úÖ Deploy finalizado com sucesso na stack $STACK_ID"
            echo "üìã Resposta do Portainer: $BODY"
            echo ""
            echo "‚ö†Ô∏è  NOTA: Se o Portainer n√£o puxar as novas imagens automaticamente,"
            echo "   verifique se h√° um registry configurado para ghcr.io no Portainer:"
            echo "   Settings > Registries > Add registry"
            echo "   Type: Docker Hub"
            echo "   URL: ghcr.io"
            echo "   Username: juniorssilvaa"
            echo "   Password: [use o GHCR_TOKEN]"
          else
            echo "‚ùå Erro ao atualizar stack no Portainer. HTTP Code: $HTTP_CODE"
            echo "üìã Resposta: $BODY"
            exit 1
          fi
